{"version":3,"sources":["assets/titleIMG.png","assets/wrongBuzzerSoundEffect.mp3","components/HowToPlay.jsx","components/Intro.jsx","components/Timer.jsx","components/Card.jsx","components/GameScreen.jsx","App.js","serviceWorker.js","index.js"],"names":["module","exports","Modal","closeModal","className","onClick","Intro","this","props","displayModal","HowToPlay","toggleDisplay","src","introIMG","alt","startGame","Component","Timer","runTime","currentTime","Math","trunc","state","startTime","Date","setState","clearInterval","interval","endGame","undefined","valueOf","setInterval","nextCard","Audio","Buzzer","play","Card","word","Fragment","answer","word1","word2","word3","word4","word5","GameScreen","currentWord","App","shuffle","deck","clonedDeck","shuffledDeck","length","randomNumber","floor","random","push","splice","e","index","bool","Boolean","window","location","hostname","match","ReactDOM","render","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.4517d01e.chunk.js","sourcesContent":["module.exports = __webpack_public_path__ + \"static/media/titleIMG.ae1e624c.png\";","module.exports = __webpack_public_path__ + \"static/media/wrongBuzzerSoundEffect.515abdc8.mp3\";","import React from 'react'\r\n\r\nconst Modal = ({ closeModal }) => {\r\n    return (\r\n        <>\r\n            <div className=\"modal wrapper\">\r\n                <h2>Game setup:</h2>\r\n                <p>\r\n                    Six or more players are divided up into two teams, with one team referred to as Team A and the other team referred to as Team B.\r\n                    504 cards are placed in the card holder and Team A selects a person in their group to be the Clue-giver. This person takes the card holder and places the first card away from his team so that they cannot see it.\r\n                    Clue cards have the clue word on the top of the card and the taboo words listed below the clue word. Clue-givers then start and keep the timer and must get their team to say the guess-word on the card without using one of the taboo words in one of their clues. If a taboo word is used then Team B must sound the buzzer which penalizes Team A by causing the current guess card to go into the discard pile.\r\n    Play is continued until time runs out. Each time a teammate successfully guesses a clue-word, a new card is placed upon the old and each card in this pile represents one point for Team A.</p>\r\n\r\n                <h2>Gameplay and Scoring:</h2>\r\n                <p>The team not giving clues must watch for Taboos or other violations of the rules. If they successfully spot a rule being broken, they may use their buzzer to interrupt play and very briefly explain the infraction. Clue-givers must place the current card into the discard pile and draw a new one. Each card in the discard pile represents one point for the other team. Once time runs out, the teams are swapped and roles are reversed. Once each player has taken a turn as clue-give, r the game ends. If teams are uneven, a player on the smaller team will be clue-giver twice.</p>\r\n\r\n                <h2>Rules:</h2>\r\n                <ol>\r\n                    <li>Clue-givers may not use any taboo words, including abbreviations and any part of the taboo word.</li>\r\n                    <li>Clue-givers may not use sound effects or use gestures to indicate the clue word.</li>\r\n                    <li>Clue-givers may pass on any card at any time, but the card is then placed in the discard pile.</li>\r\n                    <li>When time is called, the final card does not go into the discard pile, but is instead removed from play.</li>\r\n                </ol>\r\n\r\n                <h2>Scoring:</h2>\r\n                <p>Every card stacked upon another in the card holder represents one point for Team A.\r\n                    Every card stacked in the discard pile represents one point for Team B.\r\n                    The final card in play when time runs out is worth no points for either team.\r\n                    At the end of each round points are tallied for each team, the winner is declared by the team with the most points.</p>\r\n                <button onClick={closeModal}>Close</button>\r\n            </div>\r\n        </>\r\n    )\r\n}\r\n\r\nexport default Modal","import React, { Component } from \"react\";\r\nimport introIMG from '../assets/titleIMG.png'\r\nimport HowToPlay from './HowToPlay'\r\n\r\nclass Intro extends Component {\r\n    render() {\r\n        return (\r\n            this.props.displayModal ?\r\n                <HowToPlay closeModal={this.props.toggleDisplay} />\r\n                :\r\n                <div className=\"intro\">\r\n                    <h1>Unspeakable</h1>\r\n                    <div className=\"introIMG\">\r\n                        <img src={introIMG} alt=\"\" />\r\n                    </div>\r\n                    <button onClick={this.props.startGame}>START</button>\r\n                    <button onClick={this.props.toggleDisplay}>HOW TO PLAY</button>\r\n                </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Intro","import React, { Component } from 'react';\r\nimport Buzzer from '../assets/wrongBuzzerSoundEffect.mp3'\r\n\r\nclass Timer extends Component {\r\n    constructor() {\r\n        super()\r\n        this.state = {\r\n            startTime: 0,\r\n            currentTime: undefined\r\n        }\r\n    }\r\n\r\n    runTime = () => {\r\n        const currentTime = Math.trunc((this.state.startTime - new Date()) / 1000)\r\n        this.setState({\r\n            currentTime\r\n        })\r\n        if (this.state.currentTime <= 0) {\r\n            clearInterval(this.interval)\r\n            this.props.endGame()\r\n        }\r\n    }\r\n\r\n    componentDidMount() {\r\n        const startTime = new Date().valueOf() + 90000\r\n        this.setState({\r\n            startTime\r\n        })\r\n        this.interval = setInterval(() => this.runTime(), 100)\r\n    }\r\n\r\n    componentWillUnmount() {\r\n        this.props.nextCard()\r\n        const buzzer = new Audio(Buzzer)\r\n        buzzer.play()\r\n    }\r\n\r\n    render() {\r\n        return (\r\n            <div className=\"timer\">\r\n                {this.state.currentTime}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Timer","import React, { Component } from \"react\";\r\n\r\nclass Card extends Component {\r\n    render() {\r\n        return (\r\n            <div className=\"card wrapper\">\r\n                {this.props.word ?\r\n                    <React.Fragment>\r\n                        <h1>{this.props.word.answer}</h1>\r\n                        <ul>\r\n                            <li>{this.props.word.word1}</li>\r\n                            <li>{this.props.word.word2}</li>\r\n                            <li>{this.props.word.word3}</li>\r\n                            <li>{this.props.word.word4}</li>\r\n                            <li>{this.props.word.word5}</li>\r\n                        </ul>\r\n                    </React.Fragment>\r\n                    :\r\n                    <div className=\"preloader\">\r\n                        <p>Loading...</p>\r\n                    </div>}\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default Card","import React, { Component } from 'react';\r\nimport Timer from './Timer';\r\nimport Card from './Card'\r\n\r\nclass GameScreen extends Component {\r\n\r\n    render() {\r\n        return(\r\n            <div className=\"gameScreen\">\r\n                <Timer endGame={this.props.endGame} nextCard={this.props.nextCard} />\r\n                <Card word={this.props.currentWord} />\r\n                <button className=\"nextButton\" onClick={this.props.nextCard}>NEXT</button>\r\n            </div>\r\n        )\r\n    }\r\n}\r\n\r\nexport default GameScreen","import React, { Component } from 'react';\nimport deck from \"./deck/deck.json\"\nimport './App.css';\n// import Card from \"./components/Card.js\"\n// import Timer from \"./components/Timer.js\"\nimport Intro from \"./components/Intro\"\nimport GameScreen from './components/GameScreen'\n// import HowToPlay from './components/HowToPlay'\n\nclass App extends Component {\n  constructor() {\n    super()\n    this.state = {\n      deck: undefined,\n      index: 0,\n      currentWord: undefined,\n      startGame: false,\n      displayModal: false\n    }\n  }\n\n\n  shuffle = (deck) => {\n    let clonedDeck = [...deck]\n    let shuffledDeck = []\n\n    while (clonedDeck.length > 0) {\n      let randomNumber = Math.floor(Math.random() * clonedDeck.length)\n      shuffledDeck.push(clonedDeck[randomNumber])\n      clonedDeck.splice(randomNumber, 1)\n    }\n\n    return shuffledDeck\n  }\n\n  nextCard = (e) => {\n    let index = this.state.index + 1\n    const deck = this.state.deck\n\n    if (index > this.state.deck.length - 1) {\n      index = 0\n    }\n\n    this.setState({\n      index,\n      currentWord: deck[index]\n    })\n  }\n\n  startGame = (e) => {\n    this.setState({\n      startGame: true,\n    })\n  }\n\n  endGame = (e) => {\n    this.setState({\n      startGame: false,\n    })\n  }\n\n  toggleDisplay = () => {\n    const bool = !this.state.displayModal\n    this.setState({\n      displayModal: bool\n    })\n  }\n\n  componentDidMount() {\n    const shuffledDeck = this.shuffle(deck)\n    const currentWord = shuffledDeck[this.state.index]\n    this.setState({\n      deck: shuffledDeck,\n      currentWord: currentWord\n    })\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"wrapper\">\n          {this.state.startGame ?\n            <GameScreen endGame={this.endGame} nextCard={this.nextCard} currentWord={this.state.currentWord} onClick={this.nextCard} />\n            :\n            <Intro startGame={this.startGame} toggleDisplay={this.toggleDisplay} displayModal={this.state.displayModal} />\n          }\n        </div>\n      </div>\n    )\n  }\n}\n\nexport default App;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(<App />, document.getElementById('root'));\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}